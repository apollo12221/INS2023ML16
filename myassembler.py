# -*- coding: utf-8 -*-
"""myAssembler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pfu-xlwLvpE-PJeh8oLT8ffQuF6qpwQG
"""

import sys
import os
import re

instDict = {
    "nop": 0, "add": 1, "sub": 2, "and": 3, "jal": 4, "slt": 5, "nand": 6, "lui": 7,
    "bez": 8, "addi": 9, "ori": 10, "lh": 11, "sh": 12, "sll": 13, "srl": 14, "jr": 15
}

regDict = {
    "zero": 0, "r1": 1, "v0": 2, "v1": 3, "a0": 4, "a1": 5, "t0": 6, "t1": 7,
    "t2": 8, "s0": 9, "s1": 10, "s2": 11, "r12": 12, "gp": 13, "sp": 14, "ra": 15
}

numOps = {
    "nop": 0, "add": 3, "sub": 3, "and": 3, "jal": 1, "slt": 3, "nand": 3, "lui": 2,
    "bez": 2, "addi": 2, "ori": 2, "lh": 3, "sh": 2, "sll": 3, "srl": 3, "jr": 1
}

hex2num = {
    "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9,
    "A": 10, "B": 11, "C": 12, "D": 13, "E": 14, "F": 15
}

unresolvedJumps = dict() #address as the key, label string as the value
unresolvedJumpLine = dict() #address as the key, line count as the value
unresolvedBranches = dict() #address as the key, label string as the value
unresolvedBranchLine = dict() #address as the key, line count as the value
unresolvedJals = dict()
unresolvedJalLine = dict()

labelAddr = dict() #label string as the key, address as the value

srcfile = sys.argv[1]

hexfile = open("a.hex", 'w')

success = True

lineCnt = 0

hexNums = [0, 0, 0, 0]

currAddr = 0

byteData = []

firstDataAddr = 4096

codeWithData = True

def addLine(file, array, addr):
  checksum = 2
  file.write(":02") #data length
  checksum += (addr//256)%256
  file.write(hex(((addr//256)%256)//16)[2].upper()) #address high byte
  file.write(hex(((addr//256)%256)%16)[2].upper())
  checksum += addr%256
  file.write(hex((addr%256)//16)[2].upper()) #address low byte
  file.write(hex((addr%256)%16)[2].upper())
  checksum += 0
  file.write(hex(0)[2].upper()) #data type
  file.write(hex(0)[2].upper())
  checksum += array[0]*16+array[1]
  file.write(hex(array[0])[2].upper()) #data hex digit 3
  file.write(hex(array[1])[2].upper()) #data hex digit 2
  checksum += array[2]*16+array[3]
  file.write(hex(array[2])[2].upper()) #data hex digit 1
  file.write(hex(array[3])[2].upper()) #data hex digit 0
  checksum = checksum % 256
  checksum = (~checksum)%256 + 1
  checksum &= 255
  file.write(hex(checksum//16)[2].upper()) #check sum high hex digit
  file.write(hex(checksum%16)[2].upper()) #check sum low hex digit
  file.write("\x0d\n")

def checkUnresolvedJumps(Jumps, Lines, Addresses):
  for j in Jumps:
    if Jumps[j] not in Addresses: return Lines[j]
  return -1

def checkUnresolvedBranches(Branches, Lines, Addresses):
  for b in Branches:
    if Branches[b] not in Addresses: return Lines[b]
  return -1

def checkUnresolvedJals(Jals, Lines, Addresses):
  for j in Jals:
    if Jals[j] not in Addresses: return Lines[j]
  return -1

def resolveJump(outputFile, unresolvedJumps, labelAddr, hcnt):
  targetAddr = labelAddr[unresolvedJumps[hcnt]] # hcnt is the jump instruction's address
  instBuf = [7, 1, ((targetAddr//256)%256)//16, ((targetAddr//256)%256)%16] # insert: lui r1, targetAddr[15:8]
  addLine(outputFile, instBuf, hcnt)
  instBuf = [10, 1, (targetAddr%256)//16, (targetAddr%256)%16] #insert: ori r1, targetAddr[7:0]
  addLine(outputFile, instBuf, hcnt + 1)


def resolveBranch(outputFile, unresolvedBranches, labelAddr, hcnt, line):
  targetAddr = labelAddr[unresolvedBranches[hcnt]]
  targetOffset = targetAddr - hcnt - 1
  targetOffset &= 255 # the last byte of the 2's complement must be kept
  instBuf = [8, hex2num[line[10]], (targetOffset//16)%16, targetOffset%16]
  addLine(outputFile, instBuf, hcnt)

def resolveJal(outputFile, unresolvedJals, labelAddr, hcnt):
  targetAddr = labelAddr[unresolvedJals[hcnt]]
  targetOffset = targetAddr - hcnt - 1
  targetOffset &= 4095 # the last 12 bits of the 2's complement must be kept
  instBuf = [4, targetOffset//256, (targetOffset//16)%16, targetOffset%16]
  addLine(outputFile, instBuf, hcnt)

with open(srcfile, 'r') as f:
  while True:
    line = f.readline()
    if line=='': break #end of file reached
    lineCnt += 1
    line = line.lstrip()
    line = line.rstrip()
    line = line.lower()
    #print(line)
    if len(line)==0: continue ## an empty line
    elif line[0]=="#": continue ## find a comment line, no parsing
    else:
      words = re.split("\s+,\s+|\s+,|,\s+|,|\s+", line)
      #print(words)
      instPos = 0
      if words[0] == ".byte": #this is a byte array to be stored somewhere in memory (not instruction)
        for bb in words[1:]: 
          if (len(bb)!=2) or (bb[0].upper() not in hex2num) or (bb[1].upper() not in hex2num):
            success = False
            print("Error: incorrect format for data in line %d" % (lineCnt))
            break
          else: byteData.append(bb.upper())
        continue
      if words[0][-1] == ":": #this is a label
        instPos = 1
      if words[instPos] not in instDict: # illegal words
        success = False
        print("Error: illegal instruction in line %d" % (lineCnt))
        break
      elif len(words[instPos:-1])<numOps[words[instPos]]:
        success = False
        print("Error: insufficient number of operands in line %d" % (lineCnt))
        break
      else: #now parse
        if instPos==1: #process the label preceding the current line
            if words[0][0:-1] in labelAddr:
              success = False
              print("Error: duplicate label in line %d" % (lineCnt))
              break
            else: # label never added
              labelAddr[words[0][0:-1]]=currAddr
        
        hexNums = [0, 0, 0, 0]
        hexNums[0] = instDict[words[instPos]]

        if words[instPos] == "nop":
          addLine(hexfile, hexNums, currAddr)
          currAddr += 1 #any successfully parsed line will increment current address
          continue # nop has no operands
        elif words[instPos] == "jal":
          if words[instPos+1] in labelAddr: #label already exists
            targetAddr = labelAddr[words[instPos+1]]
            targetOffset = targetAddr - currAddr - 1
            targetOffset &= 4095 # the last 12 bits of the 2's complement must be kept
            hexNums[1] = targetOffset//256
            hexNums[2] = (targetOffset//16)%16
            hexNums[3] = targetOffset%16
            addLine(hexfile, hexNums, currAddr)
            currAddr += 1
            continue
          elif words[instPos+1].isdigit() or (words[instPos+1][0]=="-" and words[instPos+1][1:].isdigit()): # do NOT use digits as line labels 
            targetOffset = int(words[instPos+1])
            targetOffset &= 4095 # the last 12 of the 2's complement must be kept
            hexNums[1] = targetOffset//256
            hexNums[2] = (targetOffset//16)%16
            hexNums[3] = targetOffset%16
            addLine(hexfile, hexNums, currAddr)
            currAddr += 1
            continue
          else: #jal to an unresolved label
            instBuf = [4, 0, 0, 0] # insert: jal 0
            addLine(hexfile, instBuf, currAddr)
            unresolvedJals[currAddr] = words[instPos+1] # unresolved labels must be resolved after the entire file is parsed
            unresolvedJalLine[currAddr] = lineCnt
            currAddr += 1
            continue
        elif words[instPos] == "jr":
          if words[instPos+1] in regDict:
            hexNums[1] = regDict[words[instPos+1]]
            addLine(hexfile, hexNums, currAddr)
            currAddr += 1 #any successfully parsed line will increment current address
            continue # jr takes only one reg as the operand
          else: #possibly jump to some label, and therefore the jr is a pseudo statement
            if words[instPos+1] in labelAddr: #label already exists
              targetAddr = labelAddr[words[instPos+1]]
              instBuf = [7, 1, ((targetAddr//256)%256)//16, ((targetAddr//256)%256)%16] # insert: lui r1, targetAddr[15:8]
              addLine(hexfile, instBuf, currAddr)
              currAddr += 1
              instBuf = [10, 1, (targetAddr%256)//16, (targetAddr%256)%16] #insert: ori r1, targetAddr[7:0]
              addLine(hexfile, instBuf, currAddr)
              currAddr += 1
              instBuf = [15, 1, 0, 0] #translate the pseudo jump into: jr r1
              addLine(hexfile, instBuf, currAddr)
              currAddr += 1
              continue
            else: #label not yet in labelAddr dictionary, unresolved label
              instBuf = [7, 1, 0, 0] # insert: lui r1, 0
              addLine(hexfile, instBuf, currAddr)
              unresolvedJumps[currAddr] = words[instPos+1] # unresolved labels must be resolved after the entire file is parsed
              unresolvedJumpLine[currAddr] = lineCnt
              currAddr += 1
              instBuf = [10, 1, 0, 0] #insert: ori r1, 0
              addLine(hexfile, instBuf, currAddr)
              currAddr += 1
              instBuf = [15, 1, 0, 0] #translate the pseudo jump into: jr r1
              addLine(hexfile, instBuf, currAddr)
              currAddr += 1
              continue
        elif words[instPos] == "bez":
          if words[instPos+1] in regDict:
            hexNums[1] = regDict[words[instPos+1]]            
            if words[instPos+2].isdigit() or (words[instPos+2][0]=="-" and words[instPos+2][1:].isdigit()): # an integer value will be the direct branch offset
              targetOffset = int(words[instPos+2])
              targetOffset &= 255 # the last byte of the 2's complement must be kept
              hexNums[2] = (targetOffset//16)%16
              hexNums[3] = targetOffset%16
              addLine(hexfile, hexNums, currAddr)
              currAddr += 1
              continue
            else: # otherwise a pseudo branch instruction, and the branch label must be translated into a real one
              if words[instPos+2] in labelAddr:
                targetAddr = labelAddr[words[instPos+2]]
                targetOffset = targetAddr - currAddr - 1
                targetOffset &= 255 # the last byte of the 2's complement must be kept
                hexNums[2] = (targetOffset//16)%16
                hexNums[3] = targetOffset%16
                addLine(hexfile, hexNums, currAddr)
                currAddr += 1
                continue
              else:
                hexNums[2] = 0
                hexNums[3] = 0
                unresolvedBranches[currAddr] = words[instPos+2] # must be resolved after the entire file is parsed
                unresolvedBranchLine[currAddr] = lineCnt
                addLine(hexfile, hexNums, currAddr)
                currAddr += 1
                continue
          else:
            success = False
            print("Error: incorrect register name in line %d" % (lineCnt))
            break
        else: # non-nop and non-control instructions
          if words[instPos+1] not in regDict:
            success = False
            print("Error: incorrect register name in line %d" % (lineCnt))
            break
          else:
            if words[instPos] == "addi" or words[instPos] == "ori" or words[instPos] == "lui":
              hexNums[1] = regDict[words[instPos+1]]
              if words[instPos+2].isdigit() or (words[instPos+2][0] == "-" and words[instPos+2][1:].isdigit()):
                targetValue = int(words[instPos+2])
                targetValue &= 255 # the last byte of the 2's complement must be kept
                hexNums[2] = (targetValue//16)%16
                hexNums[3] = targetValue%16
                addLine(hexfile, hexNums, currAddr)
                currAddr += 1
                continue
              else: # currently must be a digit, in the future may allow users to define symbols for constants
                success = False
                print("Error: no immediate value provided in line %d" % (lineCnt))
                break
            elif words[instPos] == "sh":
              hexNums[1] = regDict[words[instPos+1]]
              if words[instPos+2] not in regDict:
                success = False
                print("Error: incorrect register name in line %d" % (lineCnt))
                break
              else:
                hexNums[2] = regDict[words[instPos+2]]
                addLine(hexfile, hexNums, currAddr)
                currAddr += 1
                continue
            else:
              hexNums[3] = regDict[words[instPos+1]]
              if words[instPos+2] not in regDict:
                success = False
                print("Error: incorrect register name in line %d" % (lineCnt))
                break
              else:
                hexNums[1] = regDict[words[instPos+2]]
                if words[instPos+3] not in regDict:
                  success = False
                  print("Error: incorrect register name in line %d" % (lineCnt))
                  break
                else:
                  hexNums[2] = regDict[words[instPos+3]]
                addLine(hexfile, hexNums, currAddr)
                currAddr += 1
                continue


if success:
  resJump = checkUnresolvedJumps(unresolvedJumps, unresolvedJumpLine, labelAddr)
  if resJump != -1:
    hexfile.close()
    os.remove("a.hex")
    print("Error: Line %d - jump target %s cannot be resolved" % (unresolvedJumpLine[resJump], unresolvedJumps[resJump]))
    print("Hex file not generated due to previous errors!")
  else:
    resBranch = checkUnresolvedBranches(unresolvedBranches, unresolvedBranchLine, labelAddr)
    if resBranch != -1:
      hexfile.close()
      os.remove("a.hex")
      print("Error: Line %d - branch target %s cannot be resolved" % (unresolvedBranchLine[resBranch], unresolvedBranches[resBranch]))
      print("Hex file not generated due to previous errors!")
    else: #all labels (jump or branch) can be resolved, so resolve
      resJal = checkUnresolvedJals(unresolvedJals, unresolvedJalLine, labelAddr)
      if resJal != -1:
        hexfile.close()
        os.remove("a.hex")
        print("Error: Line %d - jal target %s cannot be resolved" % (unresolvedJalLine[resJal], unresolvedJals[resJal]))
        print("Hex file not generated due to previous errors!")
      else:
        hexfile.write(":00000001FF\x0d\n") #last line for a legal hex file
        hexfile.close()
        outputFile = open("prog1.hex", "w")
        hcnt = 0
        with open("a.hex") as middleFile:
          while True:
            line = middleFile.readline()
            if line[0:3] == ":00": # reached last line
              if codeWithData: # for assembly code that contains data segments
                for x in range(hcnt, firstDataAddr):
                  addLine(outputFile, [0, 0, 0, 0], x)
                for x in range(len(byteData)):
                  addLine(outputFile, [0, 0, hex2num[byteData[x][0]], hex2num[byteData[x][1]]], firstDataAddr+x) 
              outputFile.write(line[0:-1]+"\x0d\n")
              break
            if hcnt in unresolvedJumps:
              resolveJump(outputFile, unresolvedJumps, labelAddr, hcnt)
              middleFile.readline() #skip the following line since it has been resolved
              hcnt += 2
            elif hcnt in unresolvedBranches:
              resolveBranch(outputFile, unresolvedBranches, labelAddr, hcnt, line)
              hcnt += 1
            elif hcnt in unresolvedJals:
              resolveJal(outputFile, unresolvedJals, labelAddr, hcnt)
              hcnt += 1
            else:
              outputFile.write(line[0:-1]+"\x0d\n")
              hcnt += 1
        outputFile.close()
        os.remove("a.hex")
        print("Done: hex file generated successfully!")
else:
  hexfile.close()
  os.remove("a.hex")
  print("Hex file not generated due to previous errors!")


